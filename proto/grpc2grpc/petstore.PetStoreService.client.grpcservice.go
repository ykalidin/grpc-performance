// This file registers with grpc service. This file was auto-generated by mashling at
// 2019-05-08 12:27:36.295681002 +0530 IST m=+0.020861460
package grpc2grpc

import (
	"context"

	"errors"

	"io"
	"strings"

	"log"

	servInfo "github.com/project-flogo/grpc/activity"
	"google.golang.org/grpc"
)

type clientServicepetstorePetStoreServiceclient struct {
	serviceInfo *servInfo.ServiceInfo
}

var serviceInfopetstorePetStoreServiceclient = &servInfo.ServiceInfo{
	ProtoName:   "petstore",
	ServiceName: "PetStoreService",
}

func init() {
	servInfo.ClientServiceRegistery.RegisterClientService(&clientServicepetstorePetStoreServiceclient{serviceInfo: serviceInfopetstorePetStoreServiceclient})
}

//GetRegisteredClientService returns client implimentaion stub with grpc connection
func (cs *clientServicepetstorePetStoreServiceclient) GetRegisteredClientService(gCC *grpc.ClientConn) interface{} {
	return NewPetStoreServiceClient(gCC)
}

func (cs *clientServicepetstorePetStoreServiceclient) ServiceInfo() *servInfo.ServiceInfo {
	return cs.serviceInfo
}

func (cs *clientServicepetstorePetStoreServiceclient) InvokeMethod(reqArr map[string]interface{}) map[string]interface{} {

	clientObject := reqArr["ClientObject"].(PetStoreServiceClient)
	methodName := reqArr["MethodName"].(string)

	switch methodName {
	case "BulkUsers":
		return BulkUsers(clientObject, reqArr)
	}

	resMap := make(map[string]interface{}, 2)
	resMap["Response"] = []byte("null")
	resMap["Error"] = errors.New("Method not Available: " + methodName)
	return resMap
}

func BulkUsers(client PetStoreServiceClient, reqArr map[string]interface{}) map[string]interface{} {
	resMap := make(map[string]interface{}, 1)

	if reqArr["Mode"] != nil {
		mode := reqArr["Mode"].(string)
		if strings.Compare(mode, "rest-to-grpc") == 0 {
			resMap["Error"] = errors.New("streaming operation is not allowed in rest to grpc case")
			return resMap
		}
	}

	bReq := reqArr["strmReq"].(PetStoreService_BulkUsersServer)

	stream, err := client.BulkUsers(context.Background())
	if err != nil {
		log.Println("error while getting stream object for BulkUsers:", err)
		resMap["Error"] = err
		return resMap
	}

	waits := make(chan struct{})
	go func() {
		for {
			obj, err := bReq.Recv()
			if err == io.EOF {
				resMap["Error"] = nil
				stream.CloseSend()
				close(waits)
				return
			}
			if err != nil {
				log.Println("error occured in BulkUsers bidi Recv():", err)
				resMap["Error"] = err
				close(waits)
				return
			}
			if err := stream.Send(obj); err != nil {
				log.Println("error while sending obj with stream:", err)
				resMap["Error"] = err
				close(waits)
				return
			}
		}
	}()

	waitc := make(chan struct{})
	go func() {
		for {
			obj, err := stream.Recv()
			if err == io.EOF {
				resMap["Error"] = nil
				close(waitc)
				return
			}
			if err != nil {
				log.Println("erorr occured in BulkUsers stream Recv():", err)
				resMap["Error"] = err
				close(waitc)
				return
			}
			if sdErr := bReq.Send(obj); sdErr != nil {
				log.Println("error while sending obj with bidi Send():", sdErr)
				resMap["Error"] = sdErr
				close(waitc)
				return
			}
		}
	}()
	<-waitc
	<-waits
	return resMap
}
